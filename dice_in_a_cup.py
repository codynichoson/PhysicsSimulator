# -*- coding: utf-8 -*-
"""dice_in_a_cup.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-h9yAg8xpfeAKHmP7-vtfYcegpRG7hcv
"""

import sympy as sym
from sympy import symbols, Matrix, sin, cos, Function, solve
from sympy.abc import t
from sympy import pi
import numpy as np
import matplotlib.pyplot as plt


def trans_inverse(g):
  R_trans = g[:3,:3].T
  p = Matrix([[g[0,3]], [g[1,3]], [g[2,3]]])
  RTp = -R_trans@p
  g_inv = Matrix([[R_trans[0,0], R_trans[0,1], R_trans[0,2], RTp[0]], 
                  [R_trans[1,0], R_trans[1,1], R_trans[1,2], RTp[1]], 
                  [R_trans[2,0], R_trans[2,1], R_trans[2,2], RTp[2]],
                  [           0,            0,            0,     1]])
  
  return g_inv

def Vb_unhat(Vb):
  Vb = Matrix([[Vb[0,3]],
               [Vb[1,3]],
               [Vb[2,3]],
               [Vb[2,1]],
               [Vb[0,2]],
               [Vb[1,0]]])
  return Vb

lam = symbols('lambda')
g = 9.8
Lc = 3
Ld = 0.3
mc = 10
md = 1
Jc = (1/6)*mc*Lc**2
Jd = (1/6)*md*Ld**2

xd = Function('x_d')(t)
xd_dot = xd.diff(t)
xd_ddot = xd_dot.diff(t)

yd = Function('y_d')(t)
yd_dot = yd.diff(t)
yd_ddot = yd_dot.diff(t)

thetad = Function(r'theta_d')(t)
thetad_dot = thetad.diff(t)
thetad_ddot = thetad_dot.diff(t)

xc = Function('x_c')(t)
xc_dot = xc.diff(t)
xc_ddot = xc_dot.diff(t)

yc = Function('y_c')(t)
yc_dot = yc.diff(t)
yc_ddot = yc_dot.diff(t)

thetac = Function(r'theta_c')(t)
thetac_dot = thetac.diff(t)
thetac_ddot = thetac_dot.diff(t)

q = Matrix([xc, yc, thetac, xd, yd, thetad])
q_dot = q.diff(t)
q_ddot = q_dot.diff(t)

# TRANSFORMATIONS
# Center of cup relative to world frame
gWBc = Matrix([[cos(thetac), -sin(thetac), 0, xc],
               [sin(thetac),  cos(thetac), 0, yc],
               [          0,            0, 1,  0],
               [          0,            0, 0,  1]])
# Top left corner of cup relative to cup center
gBcBc1 = Matrix([[1, 0, 0, -Lc/2],
                 [0, 1, 0,  Lc/2],
                 [0, 0, 1,     0],
                 [0, 0, 0,     1]])
# Top right corner of cup relative to cup center
gBcBc2 = Matrix([[1, 0, 0,  Lc/2],
                 [0, 1, 0,  Lc/2],
                 [0, 0, 1,     0],
                 [0, 0, 0,     1]])
# Bottom right corner of cup relative to cup center
gBcBc3 = Matrix([[1, 0, 0,  Lc/2],
                 [0, 1, 0, -Lc/2],
                 [0, 0, 1,     0],
                 [0, 0, 0,     1]])
# Bottom left corner of cup relative to cup center
gBcBc4 = Matrix([[1, 0, 0, -Lc/2],
                 [0, 1, 0, -Lc/2],
                 [0, 0, 1,     0],
                 [0, 0, 0,     1]])

# Center of dice relative to cup center
gWBd = Matrix([[cos(thetad), -sin(thetad), 0, xd],
                [sin(thetad),  cos(thetad), 0, yd],
                [          0,            0, 1,  0],
                [          0,            0, 0,  1]])
# Top left corner of dice relative to dice center
gBdBd1 = Matrix([[1, 0, 0, -Ld/2],
                 [0, 1, 0,  Ld/2],
                 [0, 0, 1,     0],
                 [0, 0, 0,     1]])
# Top right corner of dice relative to dice center
gBdBd2 = Matrix([[1, 0, 0,  Ld/2],
                 [0, 1, 0,  Ld/2],
                 [0, 0, 1,     0],
                 [0, 0, 0,     1]])
# Bottom right corner of dice relative to dice center
gBdBd3 = Matrix([[1, 0, 0,  Ld/2],
                 [0, 1, 0, -Ld/2],
                 [0, 0, 1,     0],
                 [0, 0, 0,     1]])
# Bottom left corner of dice relative to dice center
gBdBd4 = Matrix([[1, 0, 0, -Ld/2],
                 [0, 1, 0, -Ld/2],
                 [0, 0, 1,     0],
                 [0, 0, 0,     1]])

# Transformation from world to dice center-of-mass
gWBd_inv = trans_inverse(gWBd)
gWBd_dot = gWBd.diff(t)

gWBc_inv = trans_inverse(gWBc)
gWBc_dot = gWBc.diff(t)

VbHat_WBc = gWBc_inv@gWBc_dot
VbHat_WBd = gWBd_inv@gWBd_dot

# Calculate Vb
Vb_WBc = Vb_unhat(VbHat_WBc)
Vb_WBd = Vb_unhat(VbHat_WBd)

I = Matrix([[1,0,0],
            [0,1,0], 
            [0,0,1]])

inertial_mat_c = Matrix([[mc, 0,  0, 0, 0,  0],
                         [0, mc,  0, 0, 0,  0],
                         [0,  0, mc, 0, 0,  0],
                         [0,  0,  0, 0, 0,  0],
                         [0,  0,  0, 0, 0,  0],
                         [0,  0,  0, 0, 0, Jc]])

inertial_mat_d = Matrix([[md, 0,  0, 0, 0,  0],
                         [0, md,  0, 0, 0,  0],
                         [0,  0, md, 0, 0,  0],
                         [0,  0,  0, 0, 0,  0],
                         [0,  0,  0, 0, 0,  0],
                         [0,  0,  0, 0, 0, Jd]])

KE = 0.5*Vb_WBc.T @ inertial_mat_c @ Vb_WBc + 0.5*Vb_WBd.T @ inertial_mat_d @ Vb_WBd
# display(KE[0])
y_WBc = gWBc@Matrix([[0],[0],[0],[1]])
y_WBd = gWBd@Matrix([[0],[0],[0],[1]])
PE = mc*g*(y_WBc[1]) + md*g*(y_WBd[1])
# display(PE)

print('\n\033[1mLagrangian:')
Lagrangian = KE[0] - PE
Lagrangian = Matrix([Lagrangian])
Lagrangian = sym.simplify(Lagrangian)
display(Lagrangian)

# E-L stuff
dLdq = Lagrangian.jacobian(q).T
dLdqdot = Lagrangian.jacobian(q_dot).T
ddLdqdot_dt = dLdqdot.diff(t)

# EL equations
print('\n\033[1mEuler-Lagrange Equations:')
EL = (ddLdqdot_dt - dLdq)
EL = sym.simplify(EL)

rhs = Matrix([0, mc*g+10, 0, 0, 0, 0])
EL_eqn = sym.Eq(EL, rhs)
display(EL_eqn)

el_soln = sym.solve(EL_eqn, q_ddot, dict=True)[0]

xc_ddot_func = sym.lambdify([*q, *q_dot], el_soln[q_ddot[0]], modules=sym)
yc_ddot_func = sym.lambdify([*q, *q_dot], el_soln[q_ddot[1]], modules=sym)
thetac_ddot_func = sym.lambdify([*q, *q_dot], el_soln[q_ddot[2]], modules=sym)
xd_ddot_func = sym.lambdify([*q, *q_dot], el_soln[q_ddot[3]], modules=sym)
yd_ddot_func = sym.lambdify([*q, *q_dot], el_soln[q_ddot[4]], modules=sym)
thetad_ddot_func = sym.lambdify([*q, *q_dot], el_soln[q_ddot[5]], modules=sym)

# Impact Equations

# Dice corners
pd1 = Matrix([-Ld/2, Ld/2, 0, 1])
pd2 = Matrix([ Ld/2, Ld/2, 0, 1])
pd3 = Matrix([ Ld/2,-Ld/2, 0, 1])
pd4 = Matrix([-Ld/2,-Ld/2, 0, 1])

# Dice corners in cup frame
pcd1 = trans_inverse(gWBc) @ gWBd @ pd1
pcd2 = trans_inverse(gWBc) @ gWBd @ pd2
pcd3 = trans_inverse(gWBc) @ gWBd @ pd3
pcd4 = trans_inverse(gWBc) @ gWBd @ pd4

# Dice first corner impact conditions
phi1_pd1 = pcd1[0] + Lc/2
phi2_pd1 = pcd1[0] - Lc/2
phi3_pd1 = pcd1[1] + Lc/2
phi4_pd1 = pcd1[1] - Lc/2

# Dice second corner impact conditions
phi1_pd2 = pcd2[0] + Lc/2
phi2_pd2 = pcd2[0] - Lc/2
phi3_pd2 = pcd2[1] + Lc/2
phi4_pd2 = pcd2[1] - Lc/2

# Dice third corner impact conditions
phi1_pd3 = pcd3[0] + Lc/2
phi2_pd3 = pcd3[0] - Lc/2
phi3_pd3 = pcd3[1] + Lc/2
phi4_pd3 = pcd3[1] - Lc/2

# Dice fourth corner impact conditions
phi1_pd4 = pcd4[0] + Lc/2
phi2_pd4 = pcd4[0] - Lc/2
phi3_pd4 = pcd4[1] + Lc/2
phi4_pd4 = pcd4[1] - Lc/2

# Lambdify the phis
phi1_pd1_func = sym.lambdify([xc, yc, thetac, xd, yd, thetad, xc_dot, yc_dot, thetac_dot, xd_dot, yd_dot, thetad_dot], phi1_pd1, modules=sym)
phi2_pd1_func = sym.lambdify([xc, yc, thetac, xd, yd, thetad, xc_dot, yc_dot, thetac_dot, xd_dot, yd_dot, thetad_dot], phi2_pd1, modules=sym)
phi3_pd1_func = sym.lambdify([xc, yc, thetac, xd, yd, thetad, xc_dot, yc_dot, thetac_dot, xd_dot, yd_dot, thetad_dot], phi3_pd1, modules=sym)
phi4_pd1_func = sym.lambdify([xc, yc, thetac, xd, yd, thetad, xc_dot, yc_dot, thetac_dot, xd_dot, yd_dot, thetad_dot], phi4_pd1, modules=sym)

phi1_pd2_func = sym.lambdify([xc, yc, thetac, xd, yd, thetad, xc_dot, yc_dot, thetac_dot, xd_dot, yd_dot, thetad_dot], phi1_pd2, modules=sym)
phi2_pd2_func = sym.lambdify([xc, yc, thetac, xd, yd, thetad, xc_dot, yc_dot, thetac_dot, xd_dot, yd_dot, thetad_dot], phi2_pd2, modules=sym)
phi3_pd2_func = sym.lambdify([xc, yc, thetac, xd, yd, thetad, xc_dot, yc_dot, thetac_dot, xd_dot, yd_dot, thetad_dot], phi3_pd2, modules=sym)
phi4_pd2_func = sym.lambdify([xc, yc, thetac, xd, yd, thetad, xc_dot, yc_dot, thetac_dot, xd_dot, yd_dot, thetad_dot], phi4_pd2, modules=sym)

phi1_pd3_func = sym.lambdify([xc, yc, thetac, xd, yd, thetad, xc_dot, yc_dot, thetac_dot, xd_dot, yd_dot, thetad_dot], phi1_pd3, modules=sym)
phi2_pd3_func = sym.lambdify([xc, yc, thetac, xd, yd, thetad, xc_dot, yc_dot, thetac_dot, xd_dot, yd_dot, thetad_dot], phi2_pd3, modules=sym)
phi3_pd3_func = sym.lambdify([xc, yc, thetac, xd, yd, thetad, xc_dot, yc_dot, thetac_dot, xd_dot, yd_dot, thetad_dot], phi3_pd3, modules=sym)
phi4_pd3_func = sym.lambdify([xc, yc, thetac, xd, yd, thetad, xc_dot, yc_dot, thetac_dot, xd_dot, yd_dot, thetad_dot], phi4_pd3, modules=sym)

phi1_pd4_func = sym.lambdify([xc, yc, thetac, xd, yd, thetad, xc_dot, yc_dot, thetac_dot, xd_dot, yd_dot, thetad_dot], phi1_pd4, modules=sym)
phi2_pd4_func = sym.lambdify([xc, yc, thetac, xd, yd, thetad, xc_dot, yc_dot, thetac_dot, xd_dot, yd_dot, thetad_dot], phi2_pd4, modules=sym)
phi3_pd4_func = sym.lambdify([xc, yc, thetac, xd, yd, thetad, xc_dot, yc_dot, thetac_dot, xd_dot, yd_dot, thetad_dot], phi3_pd4, modules=sym)
phi4_pd4_func = sym.lambdify([xc, yc, thetac, xd, yd, thetad, xc_dot, yc_dot, thetac_dot, xd_dot, yd_dot, thetad_dot], phi4_pd4, modules=sym)

phi_list = [phi1_pd1, phi2_pd1, phi3_pd1, phi4_pd1,
            phi1_pd2, phi2_pd2, phi3_pd2, phi4_pd2,
            phi1_pd3, phi2_pd3, phi3_pd3, phi4_pd3,
            phi1_pd4, phi2_pd4, phi3_pd4, phi4_pd4]

# s_dum = np.array([1, 2, 3, 4, 5, 6, 0, 0, 0, 0, 0, 0])

phi_func_list = [
      phi1_pd1_func,
      phi2_pd1_func, 
      phi3_pd1_func, 
      phi4_pd1_func,
      phi1_pd2_func, 
      phi2_pd2_func, 
      phi3_pd2_func, 
      phi4_pd2_func,
      phi1_pd3_func, 
      phi2_pd3_func, 
      phi3_pd3_func, 
      phi4_pd3_func,
      phi1_pd4_func, 
      phi2_pd4_func, 
      phi3_pd4_func, 
      phi4_pd4_func
]

Lagrangian = sym.Matrix([Lagrangian])
dLdq = Lagrangian.jacobian(q)
dLdqdot = Lagrangian.jacobian(q_dot)
Hamiltonian = (dLdqdot @ q_dot - Lagrangian)[0]
P = dLdqdot.T

xc_dot_s, yc_dot_s, thetac_dot_s, xd_dot_s, yd_dot_s, thetad_dot_s = sym.symbols('xdot_c, ydot_c, thetadot_c, xdot_d, ydot_d, thetadot_d')

plus_subs = {q_dot[0]:xc_dot_s, q_dot[1]:yc_dot_s, q_dot[2]:thetac_dot_s, q_dot[3]:xd_dot_s, q_dot[4]:yd_dot_s, q_dot[5]:thetad_dot_s}

soln = solve(EL_eqn, [xc_ddot, yc_ddot, thetac_ddot, xd_ddot, yd_ddot, thetad_ddot])
xc_ddot_soln = soln[xc_ddot]
yc_ddot_soln = soln[yc_ddot]
thetac_ddot_soln = soln[thetac_ddot]
xd_ddot_soln = soln[xd_ddot]
yd_ddot_soln = soln[yd_ddot]
thetad_ddot_soln = soln[thetad_ddot]

display(Matrix([soln]))

import numpy as np
# eval solutions as numerical functions
xc_ddot_func = sym.lambdify([xc, yc, thetac, xd, yd, thetad, xc_dot, yc_dot, thetac_dot, xd_dot, yd_dot, thetad_dot], xc_ddot_soln)
yc_ddot_func = sym.lambdify([xc, yc, thetac, xd, yd, thetad, xc_dot, yc_dot, thetac_dot, xd_dot, yd_dot, thetad_dot], yc_ddot_soln)
thetac_ddot_func = sym.lambdify([xc, yc, thetac, xd, yd, thetad, xc_dot, yc_dot, thetac_dot, xd_dot, yd_dot, thetad_dot], thetac_ddot_soln)
xd_ddot_func = sym.lambdify([xc, yc, thetac, xd, yd, thetad, xc_dot, yc_dot, thetac_dot, xd_dot, yd_dot, thetad_dot], xd_ddot_soln)
yd_ddot_func = sym.lambdify([xc, yc, thetac, xd, yd, thetad, xc_dot, yc_dot, thetac_dot, xd_dot, yd_dot, thetad_dot], yd_ddot_soln)
thetad_ddot_func = sym.lambdify([xc, yc, thetac, xd, yd, thetad, xc_dot, yc_dot, thetac_dot, xd_dot, yd_dot, thetad_dot], thetad_ddot_soln)

import numpy as np
import matplotlib.pyplot as plt

# Initial state (xc, yc, thetac, xd, yd, thetad, xc_dot, yc_dot, thetac_dot, xd_dot, yd_dot, thetad_dot)
s0 = np.array([   0,  0,      0,  0,  1,   pi/8,      0,      0,          0,      0,      0,         0])

def impact_condition(s, threshold=0.1):
  for i in range(len(phi_func_list)):
    if phi_func_list[i](*s) > -threshold and phi_func_list[i](*s) < threshold:
      print("IMPACT")
      return phi_list[i]
  return False

# define impact update function
def impact_update(s, phi):
  lam = symbols('lambda')

  H_plus = sym.simplify(Hamiltonian.subs(plus_subs))
  P_plus = sym.simplify(P.subs(plus_subs))

  P_impact = sym.simplify(P_plus - P)
  H_impact = sym.simplify(H_plus - Hamiltonian)

  gradphi = sym.simplify(phi.diff(q))

  rhs = sym.Matrix([lam*gradphi,0])
  lhs = sym.Matrix([P_impact, H_impact])

  impact_eq = sym.simplify(sym.Eq(lhs,rhs))
  
  subs_dict = {q[0]:s[0], q[1]:s[1], q[2]:s[2], q[3]:s[3], q[4]:s[4], q[5]:s[5], 
               q_dot[0]:s[6], q_dot[1]:s[7], q_dot[2]:s[8], q_dot[3]:s[9], q_dot[4]:s[10], q_dot[5]:s[11]}

  impact_update = sym.simplify(impact_eq.subs(subs_dict))
  # print(impact_update)
  impact_soln = sym.solve(impact_update, [xc_dot_s, yc_dot_s, thetac_dot_s, xd_dot_s, yd_dot_s, thetad_dot_s, lam], dict=True)
  # print(f"solution: {impact_soln}")

  if len(impact_soln) == 1:
    print("No bueno. Only one solution.")
  else:
    for i in impact_soln:
      # print(f"lambda: {i[lam]}")
      if (abs(i[lam])) < 0.00005:
        # print('I')
        pass
      else:
        s_plus = [s[0], s[1], s[2], s[3], s[4], s[5], i[xc_dot_s], i[yc_dot_s], i[thetac_dot_s], i[xd_dot_s], i[yd_dot_s], i[thetad_dot_s]]

        return s_plus

def integrate(f, xt , dt):
  """
  RK4 integration
  """
  k1 = dt*f(xt)
  k2 = dt*f(xt+k1/2.)
  k3 = dt*f(xt+k2/2.)
  k4 = dt*f(xt+k3)
  new_xt = xt + (1/6.) * (k1+2.0*k2+2.0*k3+k4)
  return new_xt

# define simualate function
def simulate_with_impact(f, x0 , tspan , dt , integrate):
  """
  simulate with impact
  """
  N = int ((max(tspan)-min(tspan))/dt)
  x = np.copy(x0)
  tvec = np.linspace(min(tspan),max(tspan),N)
  xtraj = np.zeros((len(x0),N))
  for i in range (N):
    phi = impact_condition(x)
    # print("checked phi")
    if phi != False:
      x = impact_update(x, phi)
      xtraj[:,i]=integrate(f,x,dt)
    else:
      xtraj[:,i]=integrate(f,x,dt)
    x = np.copy(xtraj[:,i])
  return xtraj

def dyn(s):
    # put in 
    return np.array([s[6], s[7], s[8], s[9], s[10], s[11], xc_ddot_func(s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7], s[8], s[9], s[10], s[11]), 
                                                           yc_ddot_func(s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7], s[8], s[9], s[10], s[11]),
                                                           thetac_ddot_func(s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7], s[8], s[9], s[10], s[11]),
                                                           xd_ddot_func(s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7], s[8], s[9], s[10], s[11]), 
                                                           yd_ddot_func(s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7], s[8], s[9], s[10], s[11]), 
                                                           thetad_ddot_func(s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7], s[8], s[9], s[10], s[11])])



traj = simulate_with_impact(dyn, s0, [0, 10], 0.01, integrate)

x = np.arange(0,10,0.01)

plt.plot(x, traj[0], label='xc')
plt.plot(x, traj[1], label='yc')
plt.plot(x, traj[3], label='xd')
plt.plot(x, traj[4], label='yd')
plt.legend()

# plt.plot(np.arange(traj.shape[1]), traj[0:2].T)
plt.show()

from numpy import sin, cos, pi
def animate_splits(q_array,Lc,Ld,T=10):
    """
    Function to generate web-based animation of two legs doing a split

    Parameters:
    ================================================
    q_array:
        trajectory of x, y, theta1, and theta2
    L:
        length of the legs
    W:
        width of the legs
    T:
        length/seconds of animation duration

    Returns: None
    """

    ################################
    # Imports required for animation.
    from plotly.offline import init_notebook_mode, iplot
    from IPython.display import display, HTML
    import plotly.graph_objects as go

    #######################
    # Browser configuration.
    def configure_plotly_browser_state():
        import IPython
        display(IPython.core.display.HTML('''
            <script src="/static/components/requirejs/require.js"></script>
            <script>
              requirejs.config({
                paths: {
                  base: '/static/base',
                  plotly: 'https://cdn.plot.ly/plotly-1.5.1.min.js?noext',
                },
              });
            </script>
            '''))
    configure_plotly_browser_state()
    init_notebook_mode(connected=False)

    ###############################################
    # Getting data
    xc=traj[0]
    yc=traj[1]
    xd=traj[3]
    yd=traj[4]

    N = len(q_array[2]) # Need this for specifying length of simulation

    ###############################################
    # Define arrays containing data for frame axes
    # In each frame, the x and y axis are always fixed
    x_axis = np.array([0.3, 0.0])
    y_axis = np.array([0.0, 0.3])
    # Use homogeneous tranformation to transfer these two axes/points
    # back to the fixed frame
    cupx = np.zeros((4,N))
    cupy = np.zeros((4,N))

    dicex = np.zeros((4,N))
    dicey = np.zeros((4,N))

    ccorner1 = np.array([-Lc/2, Lc/2, 0, 1])
    ccorner2 = np.array([Lc/2, Lc/2, 0, 1])
    ccorner3 = np.array([Lc/2, -Lc/2, 0, 1])
    ccorner4 = np.array([-Lc/2, -Lc/2, 0, 1])

    dcorner1 = np.array([-Ld/2, Ld/2, 0, 1])
    dcorner2 = np.array([Ld/2, Ld/2, 0, 1])
    dcorner3 = np.array([Ld/2, -Ld/2, 0, 1])
    dcorner4 = np.array([-Ld/2, -Ld/2, 0, 1])

    for i in range(N): # iteration through each time step
        # evaluate homogeneous transformation

        gWBc = np.array([[cos(traj[2][i]), -sin(traj[2][i]), 0, traj[0][i]],
                         [sin(traj[2][i]),  cos(traj[2][i]), 0, traj[1][i]],
                         [              0,                0, 1,          0],
                         [              0,                0, 0,          1]])
         
        gWBd = np.array([[cos(traj[5][i]), -sin(traj[5][i]), 0, traj[3][i]],
                         [sin(traj[5][i]),  cos(traj[5][i]), 0, traj[4][i]],
                         [              0,                0, 1,          0],
                         [              0,                0, 0,          1]])

        cupx[0,i] = gWBc.dot(ccorner1)[0]
        cupx[1,i] = gWBc.dot(ccorner2)[0]
        cupx[2,i] = gWBc.dot(ccorner3)[0]
        cupx[3,i] = gWBc.dot(ccorner4)[0]
        cupy[0,i] = gWBc.dot(ccorner1)[1]
        cupy[1,i] = gWBc.dot(ccorner2)[1]
        cupy[2,i] = gWBc.dot(ccorner3)[1]
        cupy[3,i] = gWBc.dot(ccorner4)[1]

        dicex[0,i] = gWBd.dot(dcorner1)[0]
        dicex[1,i] = gWBd.dot(dcorner2)[0]
        dicex[2,i] = gWBd.dot(dcorner3)[0]
        dicex[3,i] = gWBd.dot(dcorner4)[0]
        dicey[0,i] = gWBd.dot(dcorner1)[1]
        dicey[1,i] = gWBd.dot(dcorner2)[1]
        dicey[2,i] = gWBd.dot(dcorner3)[1]
        dicey[3,i] = gWBd.dot(dcorner4)[1]
        
    ####################################
    # Using these to specify axis limits.
    xm = -3 #np.min(xx1)-0.5
    xM = 3 #np.max(xx1)+0.5
    ym = -3 #np.min(yy1)-2.5
    yM = 3 #np.max(yy1)+1.5

    ###########################
    # Defining data dictionary.
    # Trajectories are here.
    data=[
        dict(name='Cup'),
        dict(name='Dice'),
        # dict(name='Joint'),
        # dict(name='World Frame X'),
        # dict(name='World Frame Y'),
        # dict(name='A Frame X'),
        # dict(name='A Frame Y')

        ]

    ################################
    # Preparing simulation layout.
    # Title and axis ranges are here.
    layout=dict(autosize=False, width=1000, height=1000,
                xaxis=dict(range=[xm, xM], autorange=False, zeroline=False,dtick=1),
                yaxis=dict(range=[ym, yM], autorange=False, zeroline=False,scaleanchor = "x",dtick=1),
                title='Splits Simulation', 
                hovermode='closest',
                updatemenus= [{'type': 'buttons',
                               'buttons': [{'label': 'Play','method': 'animate',
                                            'args': [None, {'frame': {'duration': T, 'redraw': False}}]},
                                           {'args': [[None], {'frame': {'duration': T, 'redraw': False}, 'mode': 'immediate',
                                            'transition': {'duration': 0}}],'label': 'Pause','method': 'animate'}
                                          ]
                              }]
               )

    ########################################
    # Defining the frames of the simulation.
    frames=[dict(data=[
                       dict(x=[cupx[0][k], cupx[1][k], cupx[2][k], cupx[3][k], cupx[0][k]], 
                            y=[cupy[0][k], cupy[1][k], cupy[2][k], cupy[3][k], cupy[0][k]], 
                            mode='lines',
                            line=dict(color='purple', width=3),
                            ),
                       dict(x=[dicex[0][k], dicex[1][k], dicex[2][k], dicex[3][k], dicex[0][k]], 
                            y=[dicey[0][k], dicey[1][k], dicey[2][k], dicey[3][k], dicey[0][k]], 
                            mode='lines',
                            line=dict(color='blue', width=3),
                            ),
                      #  go.Scatter(
                      #       x=[xx[k]],
                      #       y=[yy[k]],
                      #       mode="markers",
                      #       marker=dict(color="red", size=8)),
                       # World Frame
                      #  dict(x=[0,x_axis[0]], 
                      #       y=[0,x_axis[1]], 
                      #       mode='lines',
                      #       line=dict(color='green', width=3),
                      #       ),
                      #  dict(x=[0,y_axis[0]], 
                      #       y=[0,y_axis[1]], 
                      #       mode='lines',
                      #       line=dict(color='red', width=3),
                      #       ),
                      #  # A Frame
                      #  dict(x=[xx[k],xx[k]+x_axis[0]], 
                      #       y=[yy[k],yy[k]+x_axis[1]], 
                      #       mode='lines',
                      #       line=dict(color='green', width=3),
                      #       ),
                      #  dict(x=[xx[k],xx[k]+y_axis[0]], 
                      #       y=[yy[k],yy[k]+y_axis[1]], 
                      #       mode='lines',
                      #       line=dict(color='red', width=3),
                      #       )
                      ]) for k in range(N)]

    #######################################
    # Putting it all together and plotting.
    figure1=dict(data=data, layout=layout, frames=frames)           
    iplot(figure1)

traj = np.array([traj[0], traj[1], traj[2], traj[3], traj[4], traj[5]])
animate_splits(traj,Lc,Ld,T=10)